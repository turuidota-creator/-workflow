# 内容工作流上传与数据持久化逻辑规范

本文档详细记录了工作流中数据上传、ID 关联管理以及 Session 持久化的核心机制。在开发新的 Upload 功能或排查数据丢失问题时，请严格参考本规范。

## 1. 核心原则：Session 状态管理

在 React 组件中处理异步上传任务时，**严禁使用组件渲染时捕获的 `session` 变量**。

### ❌ 错误写法 (Stale Closure)

```tsx
const { getActiveSession } = useWorkflow();
const session = getActiveSession(); // 组件渲染时获取

const handleUpload = async () => {
    // 错误：这里的 session 是旧的闭包值
    // 如果用户在前一步刚更新了数据，这里可能读不到
    const id = session.context.articleId; 
    // ...
}
```

### ✅ 正确写法 (Latest Reference)

在执行上传逻辑的那一刻，重新获取最新的 Session。

```tsx
const { getActiveSession } = useWorkflow();

const handleUpload = async () => {
    // 正确：获取当前最新的 session 状态
    const latestSession = getActiveSession();
    if (!latestSession) return;
    
    const id = latestSession.context.articleId;
    // ...
}
```

---

## 2. ID 关联与更新机制

系统同时支持 **PocketBase (远程)** 和 **本地文件系统** 存储。为了处理网络故障或离线情况，ID 管理遵循以下状态机逻辑。

### ID 格式

- **PocketBase ID**: 15位字母数字组合 (例如 `5ktp6adj133pz6m`)
- **本地临时 ID**: `article_` + 时间戳 (例如 `article_1769154158401`)

### 上传与 ID 替换逻辑

当组件调用 `/api/publish` 上传文章时，后端会优先尝试存入 PocketBase。如果成功，返回真实 ID；如果失败，回退到本地并返回临时 ID。

前端必须处理 **ID 从临时转正** 的情况：

```tsx
// 判断逻辑：
// 1. 后端返回了 ID
// 2. 并且 (当前没 ID 或 当前是本地 ID 或 ID 发生了变化)
const isLocalId = currentId?.startsWith('article_');
const shouldUpdateId = data.articleId && (!currentId || isLocalId || data.articleId !== currentId);

if (shouldUpdateId) {
    // 必须更新 Session 中的 ID，否则后续步骤(如音频上传)会因使用本地 ID 报 404
    updateSession(session.id, {
        context: { ...session.context, [idKey]: data.articleId }
    });
}
```

**后续步骤依赖**：所有依赖 `articleId` 的后续步骤（如 `AudioSynthesis` 上传音频），必须在上传前校验 `articleId` 是否为有效远程 ID（非本地临时 ID），否则应提示用户先同步文章。

---

## 3. 字段存储与数据库映射

为了优化数据库性能并规避潜在的大小限制，我们将 Workflow Session 中的大数据字段进行了分拆存储。

### `workflow_sessions` 表结构映射

React Context 中的数据在保存到 Database 时，会经过 `serializeSession` (序列化) 和 `deserializeSession` (反序列化) 处理。

| Context 字段 (内存) | Database 字段 (存储) | 说明 |
| :--- | :--- | :--- |
| `context.generationState.B` | `context2` | 备选生成结果 |
| `context.podcastScript` | `podcast_script_wf` | Level 10 播客脚本 |
| `context.podcastScript7` | `podcast_script_wf_7` | Level 7 播客脚本 |
| `context.articleJson7` | `context_7` (Key: articleJson7) | Level 7 文章数据 (打包存储) |
| `context.glossary7` | `context_7` (Key: glossary7) | Level 7 词汇表 (打包存储) |

### `context_7` 的打包逻辑

为了避免不断给数据库表添加新列，我们将 Level 7 相关的所有大字段打包存入 `context_7` JSON 字段中。

**存储结构 (JSON)**:

```json
{
  "articleJson7": { ... }, // Level 7 文章 JSON
  "glossary7": { ... }     // Level 7 词汇表
}
```

**序列化逻辑 (`serializeSession`)**:

```typescript
// 1. 从 context 克隆副本
const contextClone = { ...session.context };

// 2. 将分散的字段打包
const context_7 = (contextClone.articleJson7 || contextClone.glossary7) ? {
    articleJson7: contextClone.articleJson7,
    glossary7: contextClone.glossary7
} : undefined;

// 3. 从主 context 中删除这些字段，防止双重存储
delete contextClone.articleJson7;
delete contextClone.glossary7;

// 4. 返回对象用于保存
return { ..., context: contextClone, context_7 };
```

**反序列化逻辑 (`deserializeSession`)**:
读取时必须兼容旧数据格式（旧版本 `context_7` 可能直接存放的是 articleJson7 对象）。

```typescript
if (record.context_7) {
    // 判断是否为新版打包格式
    if (record.context_7.articleJson7 !== undefined || record.context_7.glossary7 !== undefined) {
        // 新格式：解包
        if (record.context_7.articleJson7) context.articleJson7 = record.context_7.articleJson7;
        if (record.context_7.glossary7) context.glossary7 = record.context_7.glossary7;
    } else {
        // 旧格式：直接赋值
        context.articleJson7 = record.context_7;
    }
}
```

---

## 4. 关键流程总结

### A. 文章改写上传 (ArticleRewrite)

1. 用户点击上传。
2. 代码调用 `getActiveSession()` 获取最新状态，读取 `articleId7` (可能是 undefined 或本地 ID)。
3. 调用 `/api/publish`。
4. 后端创建/更新记录，返回 **真实 PocketBase ID**。
5. 前端检测到 ID 变化（或从本地 ID 变更为真实 ID），调用 `updateSession` 更新 `context.articleId7`。
6. `updateSession` 触发保存，`articleId7` 被留在主 `context` JSON 中持久化。

### B. 词汇生成与保存 (VocabularyCompletion)

1. 调用 LLM 生成 Level 7 词汇。
2. 前端调用 `updateSession` 保存到 `context.glossary7`。
3. 持久化层 (`serializeSession`) 将 `glossary7` **移出** 主 context，**打包** 进 `context_7` 字段。
4. 发送 PATCH 请求更新数据库。

### C. 音频上传 (AudioSynthesis)

1. 用户点击上传音频。
2. 代码调用 `getActiveSession()` 获取最新 `articleId7`。
3. **校验**：确保 `articleId7` 存在且不是 `article_` 开头的本地 ID。
4. 调用 `/api/podcast-upload` 将音频文件关联到该 ID 的文章记录下。
